# -*- coding: utf-8 -*-
"""Q5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G3cCDUlvLwNHyT8ZOHO42ppcFd0cPLBF
"""

import pandas as pd               # Data Handling
import numpy as np                # Data manipulation
from numpy.linalg import inv      # Calculate Matrix Inverse
import matplotlib.pyplot as plt   # Plot Graphs
import plotly.express as px       # Plot 3D figures to visualize data
import random                     # To randomize
import statistics                 # To calculate central tendencies
import warnings                   # To ignore warnings
warnings.filterwarnings('ignore')


train = pd.read_csv("/content/FMLA1Q1Data_train.csv",header = None)
test = pd.read_csv("/content/FMLA1Q1Data_test.csv",header = None)
train.columns = ["x1","x2","y"]
test.columns = ["x1","x2","y"]


XT = np.matrix(train[["x1","x2"]])
Y = np.matrix(train[["y"]])
X = XT.transpose()
XXT = np.dot(X,XT)
XXT_inv = inv(XXT)
XXT_invX = np.dot(XXT_inv,X)
Wml = np.dot(XXT_invX,Y)
print(f'The analytical solution, gives the ideal weights as \n w1 = {float(Wml[0])} and w2 = {float(Wml[1])}' )


train1 = pd.read_csv("/content/FMLA1Q1Data_train.csv",header = None)
test1 = pd.read_csv("/content/FMLA1Q1Data_test.csv",header = None)
train1.columns = ["x1","x2","y"]
test1.columns = ["x1","x2","y"]

xT = np.matrix(train1[["x1","x2"]])
y = np.matrix(train1[["y"]])

n = len(train1)

def k1(xi,xj):
    sigma = 1
    kernal = np.exp(-float(np.linalg.norm(xi-xj)**2)/(2*(sigma**2)))

    return kernal

# def k2(xi,xj):
#     p = 2
#     kernal = (float(np.dot(xi,xj.transpose()))+1)**p
#     return kernal

K = np.matrix(np.zeros((n, n)))

for i in range(n):
    for j in range(n):
        K[i,j] = k1(xT[i],xT[j])


Kinv = inv(K + np.identity(n))
alpha = np.dot(Kinv,y)


xtest = np.matrix(test1[["x1","x2"]])
ytest = test1["y"]

y_pred = []
for j in range(len(xtest)):
    ypred = 0
    for i in range(n):
        ypred += float(alpha[i])*k1(xT[i],xtest[j])

    y_pred.append(ypred)


err = 0
for i in range(len(y_pred)):
    err += (y_pred[i] - float(ytest[i]))**2
print(f'The determinant of the Kernel matrix before adding the identity is {np.linalg.det(K)}')

print(f'The error for kernel regression is {err/len(y_pred)}')